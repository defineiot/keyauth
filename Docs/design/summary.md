# 概要设计

iot-auth的设计参考了下面2个项目:
+ [openstack keystone](https://developer.openstack.org/api-ref/identity/v3/?expanded=password-authentication-with-unscoped-authorization-detail,password-authentication-with-scoped-authorization-detail)
+ [cloud foundry uaa](http://docs.cloudfoundry.org/api/uaa/#user-token-grant-21336)

## 核心概念

系统涉及到如下概念:
+ 域: 指租户, 一般是一个公司或者一个组织, 域全局唯一。
+ 用户: 系统的使用者, 域内唯一, 通过用户角色来控制用户访问系统资源的能力,  用户访问系统资源时必须携带其项目名称, 如果未携带 则使用默认项目名称
+ 用户组: 用户的集合, 域内唯一, 通过对用户组进角色的分配可以实现用户的统一授权, 通常在用户比较多时使用, 方便授权的管理
+ 项目: 项目是一组资源的集合, 域内唯一, 任何资源必须属于一个确切的项目, 项目内的用户, 共享项目资源。

+ 服务提供商: 服务功能的集合, 全局唯一, 由一个服务提供商提供服务的功能列表。
+ 角色: 角色用于控制用户对系统功能列表的访问权限, 一个角色包含一组服务的功能列表
+ 令牌(Token): 用户访问服务的凭证, 通过OAuth2的几种方式获得

关系如下:
![](xxx)


## 认证逻辑

用户访问服务的逻辑如下:
1. 用户通过用户信息(用户名, 域, 项目)以及认证手段(比如密码认证)来获取一个访问服务的token
2. 用户携带该Token访问真正的资源服务
3. 资源服务获取到用户token后, 去openauth获取该token的相关信息, 然后根据这些用户信息返回用户访问的资源。

详细的过程如下:
![](xxx)


## 鉴权逻辑

服务将自己的功能列表注册到 注册中心, 系统管理员根据需要创建角色, 并且将这些角色和服务功能进行关联, 服务验证token,获取用户的角色对应的功能列表, 进行校验, 从而实现RBAC的访问控制, 逻辑流程如下:

![](xxx)

1. 服务将自己的功能列表注册到etcd的服务功能列表注册中心
2. 系统管理员选择合适的功能列表进行分配, 创建响应的角色
3. 服务通过token验证, 获取用户角色的功能访问列表, 并检查是否有权力调用该功能。
4. 如果通过这调用功能进行用户响应。

当然系统会初始化一些默认角色: 系统管理员: 整套用户系统的超级管理员, root一般的存在, 拥有所有功能的使用权限, 并且负责角色的创建。 域管理员: 除了角色管理以及域管理(仅能查看域详情)以外的一切权限。 普通用户: 仅仅拥有该项目资源的查看权限。